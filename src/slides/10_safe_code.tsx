import { type ReactElement } from 'react'

import { IntroSlide, RevealSlides, type RevealSlidesProps } from '../components/reveal'

export function SafeCodeSlides ({ embedded }: RevealSlidesProps): ReactElement {
    return <RevealSlides embedded={embedded}>
        <IntroSlide title='Безопасный код'/>
        {/*
    - время запуска
        - можно порезать сервис на медленно и быстро рестартуюищ части
    - умение переподключаться к зависимостям
        - умение стартовать с выключенными зависимостями
        - репортинг статуса зависимостей
    - быстрые релизы и откаты
    - откат возможен всегда
        - обратная совместимость по API и данным
    - данные лучше обновлять приложением
        - обновления данных делает приложение, поддерживая обратную совместимость
    - аналитику можно считать по бекапам
    - уровень логгирования можно менять через API
    - семплирование логов — выбирается в начале либо все по запросу логгируем, либо все не логгируем
    - идемпотентные операции (особенно для внешнего API)
    - ограничения для обслуживающих операций
    - ограничения для входящих операций
    - timeouts
        - сквозные таймауты
    - репиты
    - выключатели
    - LIFO очереди и очереди с временем жизни
*/}
        <section>
            <section>
                <h1>Удобное для обслуживания приложение</h1>
            </section>
            <section>
                <h1>Время запуска</h1>
                <p>
                        Время запуска такая же важная характеристика, как и остальные.
                        Софт, который может быстро стартовать намного более устойчив к сбоям.
                </p>
            </section>
            <section>
                <h1>Быстрые релизы и откаты</h1>
                <p>
                        Быстрые релизы и откаты могут замедляться не только медленным рестартом, но и ограничениями в CI/CD.
                </p>
            </section>
            <section>
                <h1>Надо обеспечить возможность отката всегда</h1>
                <p>Нужна обратная совместимость по API и по данным</p>
                <p>Данные может обновлять само приложение</p>
                <p className='danger'>
                        Переключение feature-toggle тоже должно быть обратимо!
                </p>
            </section>
            <section>
                <h1>Умение переподключаться к зависимостям</h1>
                <p>Включая возможность стартовать без зависимостей и отчет о статусе зависимостей</p>
            </section>
            <section>
                <h1>Уплавление логами по API</h1>
                <ul>
                    <li>Умение менять уровень логгирования на лету</li>
                    <li>Умение управлять семплированием логов</li>
                    <li>Умение увеличить логгирование для конкретного запроса</li>
                </ul>
            </section>
        </section>
        <section>
            <section>
                <h1>Повторы</h1>
            </section>
            <section>
                <h1>Таймауты</h1>
                <ul>
                    <li>Нельзя доверять умолчаниям</li>
                    <li>Не надо процессить запросы, которые уже затаймаутились</li>
                    <li>Удобно иметь глобальные таймауты</li>
                </ul>
            </section>
            <section>
                <h1>Идемпотентные операции</h1>
                <p>Все операции внешнего API удобно сделать идемпотентными</p>
            </section>
            <section>
                <h1>Повторы</h1>
                <ul>
                    <li>Не забыть выключатели</li>
                    <li>Экспоненциальное затухание и случайный сдвиг по времени</li>
                    <li>Не повторять то, что уже затаймаутилось</li>
                </ul>
            </section>
            <section>
                <h1>Лимиты</h1>
                <p>
                        Сервис должен выставлять максимальный QPS и отвечать специальным кодом, если перегружен.
                </p>
                <p className='info'>
                        При нагрузочном тестировании надо обязательно выходить за лимит и заходить обратно
                </p>
            </section>
            <section>
                <h1>Очереди</h1>
                <p>Используйте LIFO очереди и очереди с фиксированным временем жизни, если применимо</p>
            </section>
        </section>
        <section>
            <h1>Спасибо!</h1>
            <h2>Вопросы?</h2>
        </section>
    </RevealSlides>
}
